package session

import (
	"context"
	"fmt"
	"strings"

	"zpmeow/internal/application/common"
	"zpmeow/internal/application/ports"
	"zpmeow/internal/domain/session"
)

type CreateSessionCommand struct {
	Name               string
	ProxyConfiguration string
	WebhookEndpoint    string
}

func (c CreateSessionCommand) Validate() error {
	if strings.TrimSpace(c.Name) == "" {
		return common.NewValidationError("name", c.Name, "session name is required")
	}

	if len(c.Name) < 3 {
		return common.NewValidationError("name", c.Name, "session name must be at least 3 characters")
	}

	if len(c.Name) > 100 {
		return common.NewValidationError("name", c.Name, "session name must not exceed 100 characters")
	}

	return nil
}

type CreateSessionResult struct {
	SessionID string
	Name      string
	Status    string
	ApiKey    string
}

type CreateSessionUseCase struct {
	sessionRepo    session.Repository
	idGenerator    ports.IDGenerator
	eventPublisher ports.EventPublisher
	logger         ports.Logger
}

func NewCreateSessionUseCase(
	sessionRepo session.Repository,
	idGenerator ports.IDGenerator,
	eventPublisher ports.EventPublisher,
	logger ports.Logger,
) *CreateSessionUseCase {
	return &CreateSessionUseCase{
		sessionRepo:    sessionRepo,
		idGenerator:    idGenerator,
		eventPublisher: eventPublisher,
		logger:         logger,
	}
}

func (uc *CreateSessionUseCase) Handle(ctx context.Context, cmd CreateSessionCommand) (*CreateSessionResult, error) {
	if err := cmd.Validate(); err != nil {
		uc.logger.Warn(ctx, "Invalid create session command", "error", err)
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	exists, err := uc.sessionRepo.Exists(ctx, cmd.Name)
	if err != nil {
		uc.logger.Error(ctx, "Failed to check session existence", "name", cmd.Name, "error", err)
		return nil, fmt.Errorf("failed to check session existence: %w", err)
	}

	if exists {
		return nil, common.NewBusinessRuleError("unique_session_name", "session with this name already exists")
	}

	apiKey := uc.idGenerator.GenerateAPIKey()

	sessionEntity, err := session.NewSession("", cmd.Name)
	if err != nil {
		uc.logger.Error(ctx, "Failed to create session entity", "name", cmd.Name, "error", err)
		return nil, fmt.Errorf("failed to create session entity: %w", err)
	}

	if cmd.ProxyConfiguration != "" {
		if err := sessionEntity.SetProxyConfiguration(cmd.ProxyConfiguration); err != nil {
			uc.logger.Warn(ctx, "Invalid proxy configuration", "proxy", cmd.ProxyConfiguration, "error", err)
			return nil, fmt.Errorf("invalid proxy configuration: %w", err)
		}
	}

	if cmd.WebhookEndpoint != "" {
		if err := sessionEntity.SetWebhookEndpoint(cmd.WebhookEndpoint); err != nil {
			uc.logger.Warn(ctx, "Invalid webhook endpoint", "webhook", cmd.WebhookEndpoint, "error", err)
			return nil, fmt.Errorf("invalid webhook endpoint: %w", err)
		}
	}

	if err := sessionEntity.SetApiKey(apiKey); err != nil {
		uc.logger.Error(ctx, "Failed to set API key", "name", cmd.Name, "error", err)
		return nil, fmt.Errorf("failed to set API key: %w", err)
	}

	generatedID, err := uc.sessionRepo.CreateWithGeneratedID(ctx, sessionEntity)
	if err != nil {
		uc.logger.Error(ctx, "Failed to persist session", "name", cmd.Name, "error", err)
		return nil, fmt.Errorf("failed to persist session: %w", err)
	}

	if err := sessionEntity.SetID(generatedID); err != nil {
		uc.logger.Warn(ctx, "Failed to assign generated ID to session entity", "sessionID", generatedID, "error", err)
	} else {
		sessionEntity.MarkCreated()
	}

	events := sessionEntity.GetEvents()
	if len(events) > 0 {
		if err := uc.eventPublisher.PublishBatch(ctx, events); err != nil {
			uc.logger.Warn(ctx, "Failed to publish domain events", "sessionID", generatedID, "error", err)
		}
		sessionEntity.ClearEvents()
	}

	uc.logger.Info(ctx, "Session created successfully", "sessionID", generatedID, "name", cmd.Name)

	return &CreateSessionResult{
		SessionID: generatedID, // Use the ID generated by PostgreSQL
		Name:      sessionEntity.Name().Value(),
		Status:    sessionEntity.Status().String(),
		ApiKey:    sessionEntity.ApiKey().Value(),
	}, nil
}
